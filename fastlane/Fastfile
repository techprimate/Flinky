default_platform(:ios)

platform :ios do
  lane :build_ci do
    # Configure CI keychain and set match to readonly to avoid prompts
    setup_ci if is_ci

    # Setup code signing
    _setup_code_signing

    # Build and export the app to an archive
    build_app(
      project: "Flinky.xcodeproj",
      scheme: "App",
      archive_path: "./Flinky.xcarchive",
      build_path: ".",
      export_options: {
        "destination" => "export",
        "method" => "app-store-connect",
        "provisioningProfiles" => {
          "com.techprimate.Flinky" => "match AppStore com.techprimate.Flinky",
          "com.techprimate.Flinky.ShareExtension" => "match AppStore com.techprimate.Flinky.ShareExtension"
        },
        "signingCertificate" => "Apple Distribution",
        "signingStyle" => "manual",
        "teamID" => "BZ362SQ6AB",
      }
    )
    
    # Upload the archive to Sentry for further analysis
    sentry_upload_build(
      auth_token: ENV["SENTRY_AUTH_TOKEN"],
      org_slug: "techprimate",
      project_slug: "flinky",
      xcarchive_path: "./Flinky.xcarchive",
    ) if is_ci
  end

  desc "Generate app icon sizes from source image using fastlane-plugin-appicon"
  lane :generate_app_icons do
    UI.message "Generating app icon sizes using fastlane-plugin-appicon"

    # Configure MiniMagick to use ImageMagick for consistent metadata handling
    require 'mini_magick'
    MiniMagick.configure { |config| config.cli = :imagemagick }

    # Use absolute paths to avoid plugin directory changes
    project_root = File.expand_path("..")
    source_image = File.join(project_root, "Resources", "AppIcon.png")
    assets_path = File.join(project_root, "Targets", "App", "Sources", "Resources", "Assets.xcassets")
    icon_output_dir = File.join(assets_path, "AppIcon.appiconset")

    UI.message "Using source image: #{File.basename(source_image)}"

    # Verify source image exists
    unless File.exist?(source_image)
      UI.user_error! "Source image not found at #{source_image}"
    end

    # Generate iOS app icons (iPhone, iPad, App Store)
    appicon(
      appicon_image_file: source_image,
      appicon_devices: [:iphone, :ipad, :ios_marketing],
      appicon_path: assets_path,
      remove_alpha: true,
      minimagick_cli: "imagemagick"
    )

    UI.message "Stripping metadata from generated icons to ensure git-reproducible output"

    # Strip metadata from all generated icon files
    Dir.glob(File.join(icon_output_dir, "*.png")).each do |icon_path|
      UI.verbose "Processing: #{File.basename(icon_path)}"

      begin
        image = MiniMagick::Image.open(icon_path)
        image.combine_options do |b|
          # Strip all existing metadata
          b << "-strip"

          # Set consistent comment
          b << "-set" << "comment" << "Generated using fastlane-plugin-appicon"

          # Exclude PNG time chunks to prevent timestamp variations
          b << "-define" << "png:exclude-chunks=tIME"

          # Set consistent timestamps to prevent git detecting changes
          timestamp = "2024-01-01T00:00:00Z"
          b << "-set" << "date:create" << timestamp
          b << "-set" << "date:modify" << timestamp
          b << "-set" << "date:timestamp" << timestamp

          # Set consistent resolution info
          b.density "72x72"
          b << "-set" << "units" << "PixelsPerInch"

          # Set consistent user time
          b << "-set" << "user:time" << "0"
        end

        # Write the processed image back
        image.write(icon_path)

      rescue => e
        UI.error "Failed to process #{icon_path}: #{e.message}"
      end
    end

    UI.success "‚úÖ All app icon sizes generated and metadata stripped successfully!"
    UI.message "Icons generated in: Targets/App/Sources/Resources/Assets.xcassets/AppIcon.appiconset/"
    UI.message "üìù Icons are now git-reproducible (no metadata changes on regeneration)"
  end

  desc "Generate screenshots"
  lane :generate_screenshots do
    UI.message "Generating screenshots"

    capture_screenshots(
      scheme: "ScreenshotUITests",
      devices: [
        "iPhone 17 Pro Max", # iPhone 6.9" display
        "iPhone 17 Pro", # iPhone 6.3" display

        "iPad Pro 13-inch (M5)", # iPad 13" display
        "iPad Pro 11-inch (M5)", # iPad 11" display
      ],
      languages: ["en-US"],

      clear_previous_screenshots: true,
      concurrent_simulators: true,
      skip_open_summary: true,

      reinstall_app: true,
      override_status_bar: true,
      localize_simulator: true,
      disable_slide_to_type: true,
      number_of_retries: 0
    )

    UI.success "‚úÖ Screenshots generated successfully!"
    UI.message "Screenshots generated in: ScreenshotUITests/Screenshots/"
  end

  desc "Push a new beta build to TestFlight"
  lane :beta do |options|
    # Configure CI keychain and set match to readonly to avoid prompts
    setup_ci if is_ci

    version_info = _increment_version_and_build
    version_number = version_info[:version]
    build_number = version_info[:build]

    _setup_code_signing
    _build_app_for_store
    _validate_app
    _setup_sentry_release(version: version_number, build: build_number)

    # Upload to TestFlight
    upload_to_testflight(
      # API Key file must be located at fastlane/api-key.json
      api_key_path: File.expand_path("./api-key.json"),
      app_version: version_number,
      build_number: build_number,

      distribute_external: options[:distribute_external] || false,
      groups: ["Friends At Sentry", "Friends Of Phil"],
      beta_app_description: "Thanks for testing Flinky!

Please focus on testing these core features:
‚Ä¢ Creating and editing links - try various URL types (websites, deep links, etc.)
‚Ä¢ Organizing links into lists with custom colors and symbols
‚Ä¢ Link sharing via QR codes, AirDrop, and standard sharing
‚Ä¢ Search functionality across your links and lists
‚Ä¢ Link management actions (edit, delete, pin, move between lists)

Pay special attention to:
‚Ä¢ App performance and responsiveness
‚Ä¢ Any crashes or unexpected behavior
‚Ä¢ UI/UX issues or confusing interactions
‚Ä¢ Accessibility with VoiceOver if possible

In case you notice any issues, please use the \"Send Feedback\" button in the app, or take a screenshot, tap on the share button and select \"Share Beta Feedback\".

Your feedback helps us improve Flinky for everyone. Thank you!"
    )

    _finalize_sentry_release(version: version_number, build: build_number)
    _commit_and_tag_version(version: version_number, build: build_number)
  end

  desc "Push a new beta build to TestFlight (CI version - creates PR instead of direct commit)"
  lane :beta_ci do |options|
    # Configure CI keychain and set match to readonly to avoid prompts
    setup_ci if is_ci

    # Check App Store Connect and bump version if needed
    version_check_result = _check_and_bump_version_if_needed
    version_number = version_check_result[:version]

    # Increment build number
    increment_build_number(xcodeproj: "Flinky.xcodeproj")
    build_number = get_build_number(xcodeproj: "Flinky.xcodeproj")

    _setup_code_signing
    _build_app_for_store
    _validate_app
    _setup_sentry_release(version: version_number, build: build_number)

    # Upload to TestFlight (internal build only, no external distribution)
    upload_to_testflight(
      # API Key file must be located at fastlane/api-key.json
      api_key_path: File.expand_path("./api-key.json"),
      app_version: version_number,
      build_number: build_number,

      distribute_external: false,
      skip_waiting_for_build_processing: false
    )

    _finalize_sentry_release(version: version_number, build: build_number)
    
    # Create PR instead of committing directly
    _create_version_pr(version: version_number, build: build_number)
  end

  desc "Publish a new build to the App Store and submit for review"
  lane :publish do
    version_info = _increment_version_and_build
    version_number = version_info[:version]
    build_number = version_info[:build]

    _build_app_for_store
    _validate_app
    _setup_sentry_release(version: version_number, build: build_number)

    # Upload metadata and binary to App Store Connect, then submit for review
    upload_to_app_store(
      api_key_path: File.expand_path("./api-key.json"),

      skip_binary_upload: false,
      overwrite_screenshots: true,
      submit_for_review: true,

      run_precheck_before_submit: false,
      precheck_include_in_app_purchases: false,

      languages: ["en-US"],
      metadata_path: File.expand_path("./metadata"),
      screenshots_path: File.expand_path("./screenshots"),

      force: true, # Skip the preview HTML

      app_review_information: {
        email_address: ENV["APP_REVIEW_EMAIL_ADDRESS"],
        phone_number: ENV["APP_REVIEW_PHONE_NUMBER"]
      }
    )

    _finalize_sentry_release(version: version_number, build: build_number)
    _commit_and_tag_version(version: version_number, build: build_number)
  end

  desc "Upload metadata to App Store Connect"
  lane :upload_metadata do
    UI.message "Uploading metadata to App Store Connect"
    upload_to_app_store(
      api_key_path: File.expand_path("./api-key.json"),

      skip_binary_upload: true,
      overwrite_screenshots: true,

      run_precheck_before_submit: false,
      precheck_include_in_app_purchases: false,

      languages: ["en-US"],
      metadata_path: File.expand_path("./metadata"),
      screenshots_path: File.expand_path("./screenshots"),

      force: true, # Skip the preview HTML

      app_review_information: {
        email_address: ENV["APP_REVIEW_EMAIL_ADDRESS"],
        phone_number: ENV["APP_REVIEW_PHONE_NUMBER"]
      }
    )
  end

  lane :setup_code_signing do
    UI.message "Syncing code signing..."
    sync_code_signing(
      type: "development",
      app_identifier: "com.techprimate.Flinky"
    )
    sync_code_signing(
      type: "appstore",
      app_identifier: "com.techprimate.Flinky"
    )
    sync_code_signing(
      type: "development",
      app_identifier: "com.techprimate.Flinky.ShareExtension"
    )
    sync_code_signing(
      type: "appstore",
      app_identifier: "com.techprimate.Flinky.ShareExtension"
    )
    UI.success "‚úÖ Code signing synced successfully!"
  end

  desc "Bump the major version number (e.g., 1.1.2 -> 2.0.0)"
  lane :bump_version_major do
    _bump_version(bump_type: "major")
    _make(target: "generate")
  end

  desc "Bump the minor version number (e.g., 1.1.2 -> 1.2.0)"
  lane :bump_version_minor do
    _bump_version(bump_type: "minor")
    _make(target: "generate")
  end

  desc "Bump the patch version number (e.g., 1.1.2 -> 1.1.3)"
  lane :bump_version_patch do
    _bump_version(bump_type: "patch")
    _make(target: "generate")
  end

  # ============================================================================
  # PRIVATE LANES
  # ============================================================================
  # These lanes are internal helpers and are not exposed in `fastlane lanes`
  # ============================================================================

  # Private lane: Bump version number in project.pbxproj
  private_lane :_bump_version do |options|
    bump_type = options[:bump_type] # "major", "minor", or "patch"
    
    # Get current version
    old_version = get_version_number(
      xcodeproj: "Flinky.xcodeproj",
      target: "Flinky"
    )
    
    # Parse version into components
    version_parts = old_version.split(".").map(&:to_i)
    major = version_parts[0] || 0
    minor = version_parts[1] || 0
    patch = version_parts[2] || 0
    
    # Increment the appropriate part
    case bump_type
    when "major"
      major += 1
      minor = 0
      patch = 0
    when "minor"
      minor += 1
      patch = 0
    when "patch"
      patch += 1
    else
      UI.user_error!("Invalid bump_type: #{bump_type}. Must be 'major', 'minor', or 'patch'")
    end
    
    new_version = "#{major}.#{minor}.#{patch}"
    
    # Update all MARKETING_VERSION entries in project.pbxproj
    project_file = File.expand_path("../Flinky.xcodeproj/project.pbxproj")
    project_content = File.read(project_file)
    
    # Replace all MARKETING_VERSION entries
    updated_content = project_content.gsub(
      /MARKETING_VERSION = #{Regexp.escape(old_version)};/,
      "MARKETING_VERSION = #{new_version};"
    )
    
    # Write the updated content back
    File.write(project_file, updated_content)
    
    UI.success "‚úÖ Version bumped from #{old_version} to #{new_version}"
  end

  # Private lane: Setup code signing for App Store Connect
  private_lane :_setup_code_signing do
    sync_code_signing(
      type: "appstore",
      readonly: true,
      app_identifier: "com.techprimate.Flinky",
      git_private_key: ENV["MATCH_GIT_PRIVATE_KEY"]
    )
    sync_code_signing(
      type: "appstore",
      readonly: true,
      app_identifier: "com.techprimate.Flinky.ShareExtension",
      git_private_key: ENV["MATCH_GIT_PRIVATE_KEY"]
    )
  end

  # Private lane: Check App Store Connect and bump patch version if current version is already published
  private_lane :_check_and_bump_version_if_needed do
    current_version = get_version_number(
      xcodeproj: "Flinky.xcodeproj",
      target: "Flinky"
    )

    UI.message "Checking App Store Connect for published version..."
    
    begin
      # Get the published version from App Store Connect
      # This action sets lane_context[SharedValues::LATEST_VERSION] with the version number
      app_store_build_number(
        api_key_path: File.expand_path("./api-key.json"),
        live: true
      )
      
      # Get the published version from lane context
      published_version = lane_context[SharedValues::LATEST_VERSION]
      
      unless published_version
        raise "Could not retrieve published version from App Store Connect"
      end
      
      UI.message "Published version on App Store Connect: #{published_version}"
      
      # Compare versions semantically
      if _version_already_published?(current_version, published_version)
        UI.important "Version #{current_version} is already published. Bumping patch version..."
        _bump_version(bump_type: "patch")
        _make(target: "generate")
        
        # Get the new version after bumping
        new_version = get_version_number(
          xcodeproj: "Flinky.xcodeproj",
          target: "Flinky"
        )
        UI.success "‚úÖ Version bumped from #{current_version} to #{new_version}"
        next { version: new_version, bumped: true }
      else
        UI.success "‚úÖ Version #{current_version} is not yet published, using current version"
        next { version: current_version, bumped: false }
      end
    rescue => e
      UI.important "‚ö†Ô∏è Failed to check App Store Connect: #{e.message}"
      UI.important "Falling back to current version without bumping"
      next { version: current_version, bumped: false }
    end
  end

  # Private lane: Compare versions to check if current version is already published
  private_lane :_version_already_published? do |current_version, published_version|
    # Parse version strings into arrays of integers
    current_parts = current_version.split(".").map(&:to_i)
    published_parts = published_version.split(".").map(&:to_i)
    
    # Compare major, minor, patch
    (0..2).each do |i|
      current_part = current_parts[i] || 0
      published_part = published_parts[i] || 0
      
      if current_part < published_part
        next false # Current version is lower, not published
      elsif current_part > published_part
        next false # Current version is higher, not published yet
      end
    end
    
    # Versions are equal, so current version is already published
    next true
  end

  # Private lane: Increment version and build number, return both values
  private_lane :_increment_version_and_build do
    version_number = get_version_number(
      xcodeproj: "Flinky.xcodeproj",
      target: "Flinky"
    )

    increment_build_number(xcodeproj: "Flinky.xcodeproj")
    build_number = get_build_number(xcodeproj: "Flinky.xcodeproj")

    next { version: version_number, build: build_number }
  end

  # Private lane: Build the app for App Store distribution
  private_lane :_build_app_for_store do
    build_app(
      project: "Flinky.xcodeproj",
      scheme: "App",

      archive_path: "./Flinky.xcarchive",
      build_path: ".",
      export_options: {
        "destination" => "export",
        "method" => "app-store-connect",
        "provisioningProfiles" => {
          "com.techprimate.Flinky" => "match AppStore com.techprimate.Flinky",
          "com.techprimate.Flinky.ShareExtension" => "match AppStore com.techprimate.Flinky.ShareExtension"
        },
        "signingCertificate" => "Apple Distribution",
        "signingStyle" => "manual",
        "teamID" => "BZ362SQ6AB",
      }
    )
  end

  # Private lane: Validate the app before upload
  private_lane :_validate_app do
    deliver(
      # API Key file must be located at fastlane/api-key.json
      api_key_path: File.expand_path("./api-key.json"),
      verify_only: true
    )
  end

  # Private lane: Setup Sentry release (create release, upload symbols, upload build, set commits)
  private_lane :_setup_sentry_release do |options|
    version_number = options[:version]
    build_number = options[:build]

    # Create Sentry release using the same format as the app
    sentry_create_release(
      auth_token: ENV["SENTRY_AUTH_TOKEN"],
      org_slug: "techprimate",
      project_slug: "flinky",

      app_identifier: "com.techprimate.Flinky",
      version: version_number
    )

    # Upload debug symbols to Sentry
    sentry_debug_files_upload(
      auth_token: ENV["SENTRY_AUTH_TOKEN"],
      org_slug: "techprimate",
      project_slug: "flinky",

      # Wait for the server to fully process uploaded files. Errors
      # can only be displayed if --wait is specified, but this will
      # significantly slow down the upload process
      wait: true
    )

    # Upload the xcarchive to Sentry for further analysis
    sentry_upload_build(
      auth_token: ENV["SENTRY_AUTH_TOKEN"],
      org_slug: "techprimate",
      project_slug: "flinky",
      xcarchive_path: "./Flinky.xcarchive",
    )
    
    # Associate commits with the release
    sentry_set_commits(
      auth_token: ENV["SENTRY_AUTH_TOKEN"],
      org_slug: "techprimate",
      project_slug: "flinky",

      app_identifier: "com.techprimate.Flinky",
      version: version_number,
      build: build_number,
      auto: true
    )
  end

  # Private lane: Finalize Sentry release after successful upload
  private_lane :_finalize_sentry_release do |options|
    version_number = options[:version]
    build_number = options[:build]

    sentry_finalize_release(
      auth_token: ENV["SENTRY_AUTH_TOKEN"],
      org_slug: "techprimate",
      project_slug: "flinky",

      app_identifier: "com.techprimate.Flinky",
      version: version_number,
      build: build_number
    )
  end

  # Private lane: Create PR for version bump (for CI use with protected branches)
  private_lane :_create_version_pr do |options|
    version_number = options[:version]
    build_number = options[:build]

    # Ensure we have GitHub token
    github_token = ENV["GITHUB_TOKEN"] || ENV["GITHUB_APP_TOKEN"]
    unless github_token
      UI.user_error!("GITHUB_TOKEN or GITHUB_APP_TOKEN environment variable is required")
    end

    # Create release branch name
    branch_name = "release/v#{version_number}+#{build_number}"
    
    UI.message "Creating release branch: #{branch_name}"

    # Ensure we're on main and up to date
    sh("git", "checkout", "main")
    sh("git", "pull", "origin", "main")

    # Create and checkout new branch
    sh("git", "checkout", "-b", branch_name)

    # Stage version changes (project.pbxproj and Root.plist are updated by build scripts)
    git_add(path: ["Flinky.xcodeproj/project.pbxproj", "Targets/App/Sources/Resources/Settings.bundle/Root.plist"])
    
    # Create commit with structured message
    commit_message = <<~MSG
      chore: Bump version to #{version_number} (#{build_number})

      action=bump,version=#{version_number},build=#{build_number}
    MSG

    git_commit(
      path: ["Flinky.xcodeproj/project.pbxproj", "Targets/App/Sources/Resources/Settings.bundle/Root.plist"],
      message: commit_message.strip
    )

    # Push branch to remote
    sh("git", "push", "-u", "origin", branch_name)

    # Create PR
    UI.message "Creating pull request..."
    
    pr_body = <<~BODY
      ## Version Bump

      - **Version**: #{version_number}
      - **Build**: #{build_number}
      - **Tag**: `v#{version_number}+#{build_number}` (will be created after merge)

      This PR bumps the version and build number for the beta release.

      The build has already been uploaded to TestFlight and is ready for testing.

      This PR will be automatically merged once all checks pass.
    BODY

    pr_result = create_pull_request(
      api_token: github_token,
      repo: "techprimate/Flinky",
      title: "chore: Bump version to #{version_number} (#{build_number})",
      body: pr_body.strip,
      head: branch_name,
      base: "main"
    )

    pr_url = pr_result[:html_url]
    pr_number = pr_result[:number]

    UI.success "‚úÖ Pull request created: #{pr_url}"

    # Enable auto-merge using GitHub GraphQL API
    UI.message "Enabling auto-merge for PR ##{pr_number}..."
    
    begin
      require 'net/http'
      require 'json'
      require 'uri'

      # First, get the PR node_id using REST API
      pr_details_uri = URI("https://api.github.com/repos/techprimate/Flinky/pulls/#{pr_number}")
      pr_details_http = Net::HTTP.new(pr_details_uri.host, pr_details_uri.port)
      pr_details_http.use_ssl = true

      pr_details_request = Net::HTTP::Get.new(pr_details_uri)
      pr_details_request["Authorization"] = "Bearer #{github_token}"
      pr_details_request["Accept"] = "application/vnd.github+json"

      pr_details_response = pr_details_http.request(pr_details_request)
      
      unless pr_details_response.code.to_i >= 200 && pr_details_response.code.to_i < 300
        raise "Failed to fetch PR details: #{pr_details_response.body}"
      end

      pr_data = JSON.parse(pr_details_response.body)
      node_id = pr_data["node_id"]

      unless node_id
        raise "Could not find node_id in PR response"
      end

      # Use GraphQL API to enable auto-merge
      graphql_uri = URI("https://api.github.com/graphql")
      graphql_http = Net::HTTP.new(graphql_uri.host, graphql_uri.port)
      graphql_http.use_ssl = true

      query = <<~GRAPHQL
        mutation {
          enablePullRequestAutoMerge(input: {
            pullRequestId: "#{node_id}"
            mergeMethod: SQUASH
          }) {
            pullRequest {
              autoMergeRequest {
                enabledAt
              }
            }
          }
        }
      GRAPHQL

      graphql_request = Net::HTTP::Post.new(graphql_uri)
      graphql_request["Authorization"] = "Bearer #{github_token}"
      graphql_request["Content-Type"] = "application/json"
      graphql_request.body = { query: query }.to_json

      graphql_response = graphql_http.request(graphql_request)
      
      if graphql_response.code.to_i >= 200 && graphql_response.code.to_i < 300
        result = JSON.parse(graphql_response.body)
        if result["errors"]
          UI.important "‚ö†Ô∏è Could not enable auto-merge: #{result['errors'].map { |e| e['message'] }.join(', ')}"
          UI.important "You may need to enable it manually in the PR: #{pr_url}"
        else
          UI.success "‚úÖ Auto-merge enabled for PR ##{pr_number}"
        end
      else
        UI.important "‚ö†Ô∏è Could not enable auto-merge automatically: #{graphql_response.body}"
        UI.important "You may need to enable it manually in the PR: #{pr_url}"
      end
    rescue => e
      UI.important "‚ö†Ô∏è Failed to enable auto-merge: #{e.message}"
      UI.important "You may need to enable it manually in the PR: #{pr_url}"
    end

    next { pr_url: pr_url, pr_number: pr_number, branch: branch_name }
  end

  # Private lane: Commit version changes and create git tag
  private_lane :_commit_and_tag_version do |options|
    version_number = options[:version]
    build_number = options[:build]

    # Create version tag
    version_tag = "v#{version_number}+#{build_number}"

    # Commit the version changes (project.pbxproj and Root.plist are updated by build scripts)
    git_add(path: ["Flinky.xcodeproj/project.pbxproj", "Targets/App/Sources/Resources/Settings.bundle/Root.plist"])
    git_commit(
      path: ["Flinky.xcodeproj/project.pbxproj", "Targets/App/Sources/Resources/Settings.bundle/Root.plist"],
      message: "chore: Bump version to #{version_number} (#{build_number})"
    )

    # Create git tag for this version
    add_git_tag(tag: version_tag)

    # Push the commit and tag to remote
    push_to_git_remote(
      remote: 'origin',
      tags: true
    )
  end

  # Private lane: Run a make target
  private_lane :_make do |options|
    UI.message "Running make target #{options[:target]}"
    target = options[:target]
    UI.user_error!("target is required") unless target
    Dir.chdir("..") do
      sh("make", target)
    end
    UI.success "‚úÖ Make target #{target} run successfully!"
  end
end
